'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.hydrate = hydrate;
exports.register = register;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
 * a map contains all custom React components, keeping this as react-com internal state
 */
var componentsFactory = {};

function parseStringRef(str, refArgs) {
  if (typeof str === 'string' && str.startsWith('$')) {
    return str.substr(1).split('.').reduce(function (accu, token) {
      return accu[token];
    }, refArgs); // eg. arguments[1]['actions']['addTodo']
  } else {
    return str;
  }
}

/**
 * This is the functionality to map an JS object to React components tree
 * @param {object} jsonObj - a plain JS described by primitives, which is losslessly serializabled to JSON format
 * @param {array} arguments - js function arguments, to handle extra arguments. eg. $0 is jsonOjb, $1 is props
 * @example App = ({todos, actions}) => hydrate(appJson, {todos, actions});
 */
function hydrate(jsonObj) {
  for (var _len = arguments.length, restArgs = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    restArgs[_key - 1] = arguments[_key];
  }

  if (Array.isArray(jsonObj)) {
    // in case of indexed childe components (array of array in jsonObj)
    return jsonObj.map(function (obj) {
      return hydrate.apply(undefined, [obj].concat(restArgs));
    }); // breaks $0
  }
  var type = void 0,
      props = {},
      children = [];
  Object.keys(jsonObj).forEach(function (key) {
    var value = jsonObj[key];
    switch (key) {
      case '$type':
        // hydrate type
        type = componentsFactory[value] || value; // assume user does NOT override React-dom components like 'div'
        break;
      case '$children':
        // hydrate children
        children = parseStringRef(value, [jsonObj].concat(restArgs));
        break;
      default:
        // hydrate props
        props[key] = parseStringRef(value, [jsonObj].concat(restArgs));
    }
  });
  if (!type) {
    throw new Error('failed to review/hydrate React COM: type must be defined with \'$type\'!');
  } // or we could default '$type=\'div\''?
  if (!children || children.length === 0) {
    // cover both empty string or empty array
    return _react2.default.createElement(type, props, null);
  }if (typeof children === 'string') {
    return _react2.default.createElement(type, props, children);
  } else {
    return _react2.default.createElement.apply(_react2.default, [type, props].concat(_toConsumableArray(children.map(function (childJsonObj) {
      return hydrate.apply(undefined, [childJsonObj].concat(restArgs));
    }))));
  }
}

function register(components) {
  if ((typeof components === 'undefined' ? 'undefined' : _typeof(components)) === 'object') {
    Object.keys(components).forEach(function (key) {
      componentsFactory[key] = components[key];
    });
  } else {
    throw new Error('not supported components type in reac-com.register');
  }
}

exports.default = {
  hydrate: hydrate,
  register: register
};
